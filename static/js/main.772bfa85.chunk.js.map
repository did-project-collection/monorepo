{"version":3,"sources":["App.jsx","helpers/Transactor.js","helpers/loadAppContracts.js","hooks/useContractConfig.js","reportWebVitals.js","index.jsx"],"names":["MetaMaskOnboarding","isMetaMaskInstalled","App","useState","alert","setAlert","config","useContractConfig","provider","setProvider","providerAndSigner","useUserProviderAndSigner","contracts","useContractLoader","signer","tx","Transactor","useEffect","a","ethers","providers","Web3Provider","window","ethereum","request","method","loadProvider","newAlert","text","setTimeout","encryptData","cleartext","accounts","params","encryptionKeyDisplay","cyphertext","stringifiableToHex","encrypt","data","decryptData","value","utils","hexlify","Buffer","from","JSON","stringify","uploadToIPFS","file","version","client","create","URL","add","cid","console","log","path","createPIN","userData","prompt","dataToUpload","NFTManager","error","getPIN","get","tokenID","tokenURI","fetch","res","json","response","deletePIN","remove","className","length","role","onClick","require","callbacks","providerOrSigner","gasPrice","etherscan","callback","Signer","isSigner","getNetwork","network","_isProvider","getSigner","notify","options","dappId","system","networkId","chainId","transactionHandler","txInformation","possibleFunction","transaction","hash","Notify","etherscanNetwork","name","etherscanTxUrl","Promise","result","parseUnits","gasLimit","sendTransaction","indexOf","emitter","on","onclick","open","notification","info","message","description","placement","txResult","listeningInterval","setInterval","getTransactionReceipt","currentTransactionReceipt","confirmations","clearInterval","wait","parse","body","obj","errorObj","e","contractListPromise","loadAppContracts","default","deployedContracts","contractsConfig","setContractsConfig","loadFunc","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.772bfa85.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport MetaMaskOnboarding from '@metamask/onboarding';\n// eslint-disable-next-line camelcase\nimport {\n  encrypt,\n  recoverPersonalSignature,\n  recoverTypedSignatureLegacy,\n  recoverTypedSignature,\n  recoverTypedSignature_v4 as recoverTypedSignatureV4,\n} from 'eth-sig-util';\nimport { ethers } from 'ethers';\nimport { toChecksumAddress } from 'ethereumjs-util';\nimport { signTypedData } from 'eth-sig-util';\nimport { create } from 'ipfs-http-client'\nimport { useContractLoader, useUserProviderAndSigner } from 'eth-hooks';\nimport { useContractConfig } from './hooks/useContractConfig';\nimport { Transactor } from './helpers/Transactor';\nconst { isMetaMaskInstalled } = MetaMaskOnboarding;\n\nfunction App() {\n  const [ alert, setAlert ] = useState(\"\");\n  const chainId = 4;\n  const config = useContractConfig();\n  const [ provider, setProvider ] = useState();\n  const providerAndSigner = useUserProviderAndSigner(provider)\n  const contracts = useContractLoader(providerAndSigner.signer, config, chainId);\n  const tx = Transactor(providerAndSigner.signer);\n  \n  useEffect( () => {\n    const loadProvider = async() => {\n      const provider = new ethers.providers.Web3Provider(window.ethereum);\n      const userAccount = await window.ethereum.request({ method: 'eth_requestAccounts' });\n      setProvider(provider);\n    }\n    loadProvider();\n  }, []);\n\n  const newAlert = (text) => {\n    setAlert(text);\n    setTimeout(() => {\n      setAlert(\"\");\n   }, 3500)\n  }\n\n  const encryptData = async(cleartext) => {\n    const accounts = await window.ethereum.request({\n      method: 'eth_accounts',\n    });\n\n    const encryptionKeyDisplay = await window.ethereum.request({\n      method: 'eth_getEncryptionPublicKey',\n      params: [accounts[0]],\n    });\n\n    const cyphertext = stringifiableToHex(\n      encrypt(\n        encryptionKeyDisplay,\n        { data: cleartext },\n        'x25519-xsalsa20-poly1305',\n      ),\n    );\n\n    return cyphertext;\n  }\n\n  const decryptData = async(cyphertext) => {\n    const accounts = await window.ethereum.request({\n      method: 'eth_accounts',\n    });\n\n    const cleartext = await window.ethereum.request({\n      method: 'eth_decrypt',\n      params: [cyphertext, accounts[0]],\n    });\n\n    return cleartext;\n  }\n\n  const stringifiableToHex = (value) => {\n    return ethers.utils.hexlify(Buffer.from(JSON.stringify(value)));\n  }\n\n  const uploadToIPFS = async (data) => {\n    const file = JSON.stringify({data: data, version: \"v1\"});\n    const client = create(new URL('https://ipfs.infura.io:5001/api/v0'));\n    const cid = await client.add(file);\n    console.log(\"[uploadToIPFS] cid\", cid.path);\n\n    return cid.path;\n  }\n\n  const createPIN = async() => {\n    console.log(\"createPIN\");\n\n    let userData = prompt(\"KYC-Chain\\nINPUT DATA\\nPlease enter your full name\", \"John Doe\");\n\n    if(userData === \"\") {\n      setAlert(\"Error: null data\");\n\n      return;\n    }\n\n    try {\n      console.log(\"Encrypting...\");\n      const dataToUpload = await encryptData(userData);\n      console.log(\"Uploading...\");\n      const cid = await uploadToIPFS(dataToUpload);\n      console.log(\"Minting...\");\n      await tx(contracts.NFTManager.create(cid));\n      console.log(\"...OK\");\n\n      newAlert(\"Token created with data:\" + userData);\n    } catch(e) {\n      console.log(\"...FAIL\");\n      console.error(e);\n      newAlert(\"Error occurred\");\n    }\n  }\n\n  const getPIN = async() => {\n    try {\n      const tokenID = await contracts.NFTManager.get();\n      const cid = await contracts.NFTManager.tokenURI(tokenID);\n      const res = await fetch(`https://ipfs.io/ipfs/${cid}`);\n      const response = await res.json();\n      const userData = await decryptData(response.data);\n      newAlert(\"Token was read and contains data: \" + userData);\n    } catch(e) {\n      console.log(\"...FAIL\");\n      console.error(e);\n      newAlert(\"Error occurred\");\n    }\n  }\n\n  const deletePIN = async() => {\n    try {\n      console.log(\"Deleting...\");\n      await tx(contracts.NFTManager.remove());\n      console.log(\"...OK\");\n      newAlert(\"Token was deleted\");\n    } catch(e) {\n      console.log(\"...FAIL\");\n      console.error(e);\n      newAlert(\"Error!\");\n    }\n  }\n\n  return (\n    <div className=\"text-center\">\n      <span className=\"form-signin\">\n        <h1 className=\"h3 mb-3 font-weight-normal\">KYC Token</h1>\n        { alert.length > 0 &&\n          <div className=\"alert alert-primary\" role=\"alert\">{alert}</div>\n        }\n        <br />\n        <button className=\"btn btn-lg btn-primary btn-block\" onClick={() => createPIN()}>Create Personal Identity NFT</button>\n        <button className=\"btn btn-lg btn-success btn-block\" onClick={() => getPIN()}>Read Personal Identity NFT</button>\n        <button className=\"btn btn-lg btn-danger btn-block\" onClick={() => deletePIN()}>Delete Personal Identity NFT</button>\n        <p className=\"mt-5 mb-3 text-muted\">Personal Identity Token</p>\n      </span>\n    </div>\n  );\n}\n\nexport default App;\n","import { notification } from \"antd\";\nimport Notify from \"bnc-notify\";\n\nconst { ethers } = require(\"ethers\");\n\n// this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\nconst callbacks = {};\nconst BLOCKNATIVE_DAPPID = \"0b58206a-f3c0-4701-a62f-73c7243e8c77\";\nconst DEBUG = false;\n\nexport const Transactor = (providerOrSigner, gasPrice, etherscan) => {\n  if (typeof providerOrSigner !== \"undefined\") {\n    // eslint-disable-next-line consistent-return\n    return async (tx, callback) => {\n      let signer;\n      let network;\n      let provider;\n      if (ethers.Signer.isSigner(providerOrSigner) === true) {\n        provider = providerOrSigner.provider;\n        signer = providerOrSigner;\n        network = providerOrSigner.provider && (await providerOrSigner.provider.getNetwork());\n      } else if (providerOrSigner._isProvider) {\n        provider = providerOrSigner;\n        signer = providerOrSigner.getSigner();\n        network = await providerOrSigner.getNetwork();\n      }\n\n      console.log(\"network\", network);\n      var options = null;\n      var notify = null;\n        options = {\n          dappId: BLOCKNATIVE_DAPPID, // GET YOUR OWN KEY AT https://account.blocknative.com\n          system: \"ethereum\",\n          networkId: network.chainId,\n          // darkMode: Boolean, // (default: false)\n          transactionHandler: txInformation => {\n            if (DEBUG) console.log(\"HANDLE TX\", txInformation);\n            const possibleFunction = callbacks[txInformation.transaction.hash];\n            if (typeof possibleFunction === \"function\") {\n              possibleFunction(txInformation.transaction);\n            }\n          },\n        };\n\n        notify = Notify(options);\n\n      let etherscanNetwork = \"\";\n      if (network.name && network.chainId > 1) {\n        etherscanNetwork = network.name + \".\";\n      }\n\n      let etherscanTxUrl = \"https://\" + etherscanNetwork + \"etherscan.io/tx/\";\n      if (network.chainId === 100) {\n        etherscanTxUrl = \"https://blockscout.com/poa/xdai/tx/\";\n      }\n\n      try {\n        let result;\n        if (tx instanceof Promise) {\n          if (DEBUG) console.log(\"AWAITING TX\", tx);\n          result = await tx;\n        } else {\n          if (!tx.gasPrice) {\n            tx.gasPrice = gasPrice || ethers.utils.parseUnits(\"4.1\", \"gwei\");\n          }\n          if (!tx.gasLimit) {\n            tx.gasLimit = ethers.utils.hexlify(120000);\n          }\n          if (DEBUG) console.log(\"RUNNING TX\", tx);\n          result = await signer.sendTransaction(tx);\n        }\n        if (DEBUG) console.log(\"RESULT:\", result);\n        // console.log(\"Notify\", notify);\n\n        if (callback) {\n          callbacks[result.hash] = callback;\n        }\n\n        // if it is a valid Notify.js network, use that, if not, just send a default notification\n        if (notify && [1, 3, 4, 5, 42, 100].indexOf(network.chainId) >= 0) {\n          const { emitter } = notify.hash(result.hash);\n          emitter.on(\"all\", transaction => {\n            return {\n              onclick: () => window.open((etherscan || etherscanTxUrl) + transaction.hash),\n            };\n          });\n        } else {\n          notification.info({\n            message: \"Local Transaction Sent\",\n            description: result.hash,\n            placement: \"bottomRight\",\n          });\n          // on most networks BlockNative will update a transaction handler,\n          // but locally we will set an interval to listen...\n          if (callback) {\n            const txResult = await tx;\n            const listeningInterval = setInterval(async () => {\n              console.log(\"CHECK IN ON THE TX\", txResult, provider);\n              const currentTransactionReceipt = await provider.getTransactionReceipt(txResult.hash);\n              if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\n                callback({ ...txResult, ...currentTransactionReceipt });\n                clearInterval(listeningInterval);\n              }\n            }, 500);\n          }\n        }\n\n        if (typeof result.wait === \"function\") {\n          await result.wait();\n        }\n\n        return result;\n      } catch (e) {\n        if (DEBUG) console.log(e);\n        // Accounts for Metamask and default signer on all networks\n        let message =\n          e.data && e.data.message\n            ? e.data.message\n            : e.error && JSON.parse(JSON.stringify(e.error)).body\n            ? JSON.parse(JSON.parse(JSON.stringify(e.error)).body).error.message\n            : e.data\n            ? e.data\n            : JSON.stringify(e);\n        if (!e.error && e.message) {\n          message = e.message;\n        }\n\n        console.log(\"Attempt to clean up:\", message);\n        try {\n          let obj = JSON.parse(message);\n          if (obj && obj.body) {\n            let errorObj = JSON.parse(obj.body);\n            if (errorObj && errorObj.error && errorObj.error.message) {\n              message = errorObj.error.message;\n            }\n          }\n        } catch (e) {\n          //ignore\n        }\n\n        notification.error({\n          message: \"Transaction Error\",\n          description: message,\n        });\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n      }\n    };\n  }\n}\n","const contractListPromise = import(\"../abi/nft.json\");\n\nexport const loadAppContracts = async () => {\n  const config = {};\n  config.deployedContracts = (await contractListPromise).default ?? {};\n  return config;\n};\n","import { useState, useEffect } from \"react\";\nimport { loadAppContracts } from \"../helpers/loadAppContracts\";\n\nexport const useContractConfig = () => {\n  const [contractsConfig, setContractsConfig] = useState({});\n\n  useEffect(() => {\n    const loadFunc = async () => {\n      const result = await loadAppContracts();\n      setContractsConfig(result);\n    };\n    void loadFunc();\n  }, []);\n  return contractsConfig;\n};\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}